import numpy as np
from cloudpickle import loads
import base64
from ember.features import PEFeatureExtractor
from pathlib import Path


labels = ['adware', 'flooder', 'ransomware', 'dropper', 'spyware', 'packed', 'crypto_miner', 'file_infector', 'installer', 'worm', 'downloader']
features = [f"feature_{x}" for x in range(2381)]

model_files =  list(Path("/opt/ml/models/").rglob("*.pkl"))
support_files = list(Path("/opt/ml/support/").rglob("*.pkl"))

models = dict()
support = dict()

for m in model_files:
    models[m.name] =  loads(m.open('rb').read())

for s in support_files:
    support[s.name] = loads(s.open('rb').read())

scaler = support.get('scaler.pkl')
k_scores = dict()
for label in labels:
    k_scores[label] = support.get(f'scores-{label}.pkl')


def handler(event, context):
    k = event.get('k', 100)
    p = event.get('p', 0.1)
    s = event.get('scaled', False)

    if 'binary' in event.keys():
        malware   = base64.b64decode(event.get('binary'))
        extractor = PEFeatureExtractor(2)
        ember_features  = list(extractor.feature_vector(malware))
    elif 'metadata' in event.keys():
        ember_features  = event.get('metadata')
    else:
        exit(-1)

    if not s:
        ember_features_scaled = scaler.transform(np.array(ember_features))
    else:
        ember_features_scaled = ember_features
    
    kbest = set()
    for label in labels:
        columns = [x[0] for x in list(sorted(k_scores[label], key=lambda i: i[1], reverse=True))[:k]]
        kbest.update(columns)
    kbest=list(sorted(list(kbest), key=lambda x: int(x.split('_')[1])))

    feature_dict = dict(zip(features, ember_features_scaled))
    feature_values = []
    for column in kbest:
        feature_values.append(feature_dict[column])

    predicted_labels = []
    probability_labels = dict()
    for label in labels:
        model  = models[f'model-{label}-{p}-{k}.pkl']
        is_this_label = model.predict(np.array([feature_values], np.float32))
        probability   = model.predict_proba(np.array([feature_values], np.float32))
        probability_labels[label] = list(probability[0])
        if is_this_label:
            predicted_labels.append(label)

    return {
        "probability": probability_labels,
        "labels": predicted_labels
    }